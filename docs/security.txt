Notes on securing NUT
=====================

The NUT Team is very interested in providing the highest security level to its
users.

Many internal and external mechanisms exist to secure NUT. And several steps are
needed to ensure that your NUT setup meets your security requirements.

This chapter will present you these mechanisms, by increasing order of security
level. This means that the more security you need, the more mechanisms you will
have to apply.

////////////////////////////////////////////////////////////////////////////////
FIXME:
reference security related QA topics 
////////////////////////////////////////////////////////////////////////////////


System level privileges and ownership
-------------------------------------

All configuration files should be protected so that the world can't read them.
Use the following commands to accomplish this:

	chown root:nut /etc/nut/*
	chmod 640 /etc/nut/*


Finally, the link:user-manual.html#StatePath[state path] directory, which
holds the communication between the driver(s) and upsd, should also be secured.

	chown root:nut /var/state/ups
	chmod 0770 /var/state/ups


NUT level user privileges
-------------------------

Administrative commands such as setting variables and the instant commands
are powerful, and access to them needs to be restricted.

NUT provides an internal mechanism to do so, through
link:man/upsd.users.html[upsd.users(5)].

This file defines who may access instant commands and settings, and what
is available.

During the initial 
link:user-manual.html#NUT_user_creation[NUT user creation], we have created a
monitoring user for upsmon.

You can also create an 'administrator' user with full power using:

	[administrator]
		password = mypass
		actions = set
		instcmds = all

For more information on how to restrict actions and instant commands, refer
to link:man/upsd.users.html[upsd.users(5)] manual page.

NOTE: NUT administrative user definitions should be used in conjunction with
<<TCP_Wrappers,TCP Wrappers>>.


Network access control
----------------------

If you are not using NUT on a standalone setup, you will need to enforce
network access to upsd.

There are various ways to do so.

NUT LISTEN directive
~~~~~~~~~~~~~~~~~~~~

link:man/upsd.conf.html[upsd.conf(5)].

   LISTEN interface port

Bind a listening port to the interface specified by its Internet address.  This
may be useful on hosts with multiple interfaces.  You should not rely
exclusively on this for security, as it can be subverted on many systems.

Listen on TCP port `port` instead of the default value which was compiled into
the code.  This overrides any value  you  may  have  set  with `configure
--with-port`.  If you don't change it with configure or this value, `upsd` will
listen on port 3493 for this interface.

Multiple LISTEN addresses may be specified.  The default is to bind to
127.0.0.1 if no LISTEN addresses are specified (and ::1 if IPv6 support is
compiled in).

	   LISTEN 127.0.0.1
	   LISTEN 192.168.50.1
	   LISTEN ::1
	   LISTEN 2001:0db8:1234:08d3:1319:8a2e:0370:7344

This parameter will only be read at startup.  You'll need to restart (rather
than reload) `upsd` to apply any changes made here.


Firewall
~~~~~~~~

NUT has its own official IANA port: 3493/tcp.

The `upsmon` process on slave systems (as well as `upsc`) connects to the
`upsd` process on the master system via this TCP port. The `upsd` process does
not connect out.

You should use this to restrict network access.


[[TCP_Wrappers]]
TCP Wrappers
~~~~~~~~~~~~

If the server is build with tcp-wrappers support enabled, it will check if the
NUT username is allowed to connect from the client address through the
'/etc/hosts.allow' and '/etc/hosts.deny' files.

NOTE: this will only be done for commands that require the user to be logged
into the server.

`hosts.allow`:

	ups : admin@127.0.0.1/32
	ups : monslave@127.0.0.1/32 monslave@192.168.1.0/24

`hosts.deny`:

	upsd : ALL

Further details are described in hosts_access(5).


Configuring SSL
---------------

include ssl.txt[]

////////////////////////////////////////////////////////////////////////////////
FIXME: note on the planned NSS port?
////////////////////////////////////////////////////////////////////////////////


chrooting and other forms of paranoia
-------------------------------------

It has been possible to run the drivers and upsd in a chrooted jail for
some time, but it involved a number of evil hacks.  From the 1.3 series,
a much saner chroot behavior exists, using BIND 9 as an inspiration.

The old way involved creating an entire tree, complete with libraries, a
shell (!), and many auxiliary files.  This was hard to maintain and
could have become an interesting playground for an intruder.  The new
way is minimal, and leaves little in the way of usable materials within
the jail.

This document assumes that you already have created at least one user
account for the software to use.  If you're still letting it fall back
on "nobody", stop right here and go figure that out first.  It also
assumes that you have everything else configured and running happily all
by itself.

Generalities
~~~~~~~~~~~~

Essentially, you need to create your configuration directory and state
path in their own little world, plus a special device or two.

For the purposes of this example, the chroot jail is /chroot/nut.  The
programs have been built with the default prefix, so they are using
/usr/local/ups.  First, create the confpath and bring over a few files.

	mkdir -p /chroot/nut/usr/local/ups/etc
	cd /chroot/nut/usr/local/ups/etc
	cp -a /usr/local/ups/etc/upsd.users .
	cp -a /usr/local/ups/etc/upsd.conf .
	cp -a /usr/local/ups/etc/ups.conf .

We're using 'cp -a' to maintain the permissions on those files.

Now bring over your state path, maintaining the same permissions as
before.

	mkdir -p /chroot/nut/var/state
	cp -a /var/state/ups /chroot/nut/var/state

Next we must put /etc/localtime inside the jail, or you may get very  
strange readings in your syslog.  You'll know you have this problem if
upsd shows up as UTC in the syslog while the rest of the system doesn't.

	mkdir -p /chroot/nut/etc
	cp /etc/localtime /chroot/nut/etc

Note that this is not "cp -a", since we want to copy the *content*, not
the symlink that it may be on some systems.

Finally, create a tiny bit of /dev so the programs can enter the
background properly - they redirect fds into the bit bucket to make sure
nothing else grabs 0-2.

	mkdir -p /chroot/nut/dev
	cp -a /dev/null /chroot/nut/dev

Try to start your driver(s) and make sure everything fires up as before.

	upsdrvctl -r /chroot/nut -u nutdev start

Once your drivers are running properly, try starting upsd.

	upsd -r /chroot/nut -u nutsrv

Check your syslog.  If nothing is complaining, try running clients like
upsc and upsmon.  If they seem happy, then you're done.

symlinks
~~~~~~~~

After you do this, you will have two copies of many things, like the
confpath and the state path.  I recommend deleting the 'real'
/var/state/ups, replacing it with a symlink to
/chroot/nut/var/state/ups.  That will let other programs reference the
.pid files without a lot of hassle.

You can also do this with your confpath and point /usr/local/ups/etc at
/chroot/nut/usr/local/ups/etc unless you're worried about something
hurting the files inside that directory.  In that case, you should
maintain a 'master' copy and push it into the chroot path after
making changes.

upsdrvctl itself does not chroot, so the ups.conf still needs to be in
the usual confpath.

upsmon
~~~~~~

This has not yet been applied to upsmon, since it can be quite
complicated when there are notifiers that need to be run.  One
possibility would be for upsmon to have three instances:

	- privileged root parent that listens for a shutdown command

	- unprivileged child that listens for notify events

	- unprivileged chrooted child that does network I/O

This one is messy, and may not happen for some time, if ever.

Config files
~~~~~~~~~~~~

You may now set chroot= and user= in the global section of ups.conf.

upsd chroots before opening any config files, so there is no way to 
add support for that in upsd.conf at the present time.
